## mysql数据类型
### 整数类型  
  tinyint,smallint,mediumint,int,bigint。分别表示1字节、2字节、3字节、4字节、8字节。任何整数类型都可以加上unsigned属性，表示数据是无符号类型，即非负整数。
### 实数类型  
  包括float，double，decimal。decimal可以用于存储比bigint还大的整数，能存储精确的小数。而float和double是有取值范围的，并支持使用标准的浮点进行近似计算。计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。
### 字符串类型  
  包括VARCHAR、CHAR、TEXT、BLOBVARCHAR用于存储可变长字符串，它比定长类型更节省空间。VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。VARCHAR存储的内容超出设置的长度时，内容会被截断。CHAR是定长的，根据定义的字符串长度分配足够的空间。CHAR会根据需要使用空格进行填充方便比较。CHAR适合存储很短的字符串，或者所有值都接近同一个长度。CHAR存储的内容超出设置的长度时，内容同样会被截断。
### 枚举类型（ENUM）  
  把不重复的数据存储为一个预定义的集合。有时可以使用ENUM代替常用的字符串类型。ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。ENUM在内部存储时，其实存的是整数。尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。排序是按照内部存储的整数
### 日期和时间类型  
 尽量使用timestamp，空间效率高于datetime，用整数保存时间戳通常不方便处理。如果需要存储微妙，可以使用bigint存储。看到这里，这道真题是不是就比较容易回答了。
## mysql索引
### 索引的优缺点
- 优点  
  可以大大加快数据的检索速度，这也是创建索引的最主要的原因。通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
- 缺点  
  时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；空间方面：索引需要占物理空间。
### 索引的类型：
- 主键索引  
  数据列不允许重复，不允许为NULL，一个表只能有一个主键。
- 唯一索引  
  数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引
- 普通索引  
  基本的索引类型，没有唯一性的限制，允许为NULL值。可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引。
- 全文索引  
  是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引
### 索引实现类型：
- BTREE
  n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。  
  所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。  
  所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。  
  B+ 树中，数据对象的插入和删除仅在叶节点上进行。  
  B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。
- HASH  
  类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。
### 索引实现原理
- MyISAM索引实现  
    MyISAM使用B+TREE作为索引结构，叶子节点的data域存放的数据记录地址。MyISAM中索引检索算法为首先按照B+Tree所搜算法搜索索引，如果指定的key存在，则取出data域的值，然后以data域的值为地址，读取相应的数据记录。
- InnoDB索引实现  
    InnoDB也采用B+TREE作为索引结构，单具体实现方式和MyISAM不同。一、InnoDB的数据文件本身就是索引文件，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。在InnoDB中，表数据文件本身就是按照B+Tree阻止的一个索引结构。这种索引及叫做聚集索引。因为InnoDB的数据文件本身要按照主键聚集，所以InnnoDB要求表必须有主键（MyISAM可以没有）。二、InnoDB的辅助索引data域存储相应记录主键的值而不是地址。

### 索引的设计原则
  适合索引的列是出现在where子句中的列，或者连接子句中指定的列。  
  基数较小的类，索引效果较差，没有必要在此列建立索引  
  使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间  
  不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
### 创建索引时需要注意什么  
- 非空字段  
  应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；  
- 取值离散大的字段  
  （变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高
- 索引字段越小越好  
  数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
### 聚簇索引  
- 聚簇索引  
  将数据存储与索引放到了一块，找到索引也就找到了数据
- 非聚簇索引  
  将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。
## 引擎
### mysql有两种引擎：
- myisam
- innodb
### 引擎的区别：
- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。
### innodb索引的4大特性
- 插入缓冲(insert buffer)
- 二次写(double write)
- 自适应哈希索引(ahi)
- 预读(read ahead)


## mysql查询优化
### 什么是最左前缀原则？什么是最左匹配原则？
顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。  
  
最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。  
  
=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式  

### 大表数据查询，怎么优化？
- 优化shema、sql语句+索引； 
- 加缓存，memcached, redis
- 主从复制，读写分离；
- 表拆分
  垂直拆分
  水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表
### 超大分页怎么处理？
  超大的分页一般从两个方向上来解决:数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击

### 主键使用自增ID还是UUID？
推荐使用自增ID，不要使用UUID。  
因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。
### 数据库结构优化？
需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。  
**将字段很多的表分解成多个表** ：对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。  
**增加中间表**：对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。  
**增加冗余字段**：设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。
## mysql锁
###  按照锁的粒度分数据库锁有哪些
- 行级锁  
  行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
- 表级锁  
  表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
- 页级锁  
  页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
### 从锁的类别上分MySQL都有哪些锁
  从锁的类别上来讲，有共享锁和排他锁。共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。
### InnoDB存储引擎的锁的算法有哪三种
- Record lock  
  单个行记录上的锁
- Gap lock  
  间隙锁，锁定一个范围，不包括记录本身
- Next-key lock 
  record+gap 锁定一个范围，包含记录本身
### 数据库的乐观锁和悲观锁是什么？怎么实现的？
- 悲观锁  
  假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
- 乐观锁  
  假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。

## 其他知识
### 主从复制的作用？
主数据库出现问题，可以切换到从数据库。  
可以进行数据库层面的读写分离。
可以在从数据库上进行日常备份。

### MySQL主从复制工作原理？
1. 在主库上把数据更高记录到二进制日志  
2. 从库将主库的日志复制到自己的中继日志
3. 从库读取中继日志的事件，将其重放到从库数据中。

### MySQL的binlog有有几种录入格式？分别有什么区别？
- statement
  statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
- row
  row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
- mixed。
  一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。