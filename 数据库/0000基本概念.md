## 数据库三大范式
- 第一范式：每一列都不可再拆分
- 第二范式：在第一范式的基础上，非主键列完全依赖主键，而不能依赖主键的一部分
- 第三范式：在第二范式的基础上，非主键列只依赖主键，不依赖其他非主键
## 事务
事务的特性：ACID
- A：原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- C：一致性；事务提交前后，数据满足预先定义的数据约束。比如设置金额大于等于0，提交事务后，该字段就不能小于等于0。
- I：隔离性；并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
- D：持续性/永久性；一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

## 隔离级别  
数据库有四种隔离级别，分别是：  
- read uncommitted 读未提交  
  所有事务可以读取其他事务未提交的内容；
- read commited 读已提交  
  事务开始时，只能读取到已经提交的内容，事务提交前，任务数据的改变，对于其他事务来说，都是不可见的。Oracle默认用此隔离级别。  
- repeatable read 可重复读
  事务开始后，读取到的内容相同，哪怕其他事务修改了该数据。mysql默认使用此隔离级别
- serializable 串行化
  最高隔离级别。在每个读的数据上都加上锁，  

|  隔离级别  | 脏读  | 不可重复读 | 幻读 | 
|:--- |:---:|:---: |:---:|
|READ UNCOMMITTED| 是 | 是 | 是 |
|READ COMMITTED | 否 | 是 | 是 |
|REPEATABLE READ | 否 | 否 | 是 | 
|SERIALIZABLE | 否 | 否 | 否|

### 脏读  
脏读是指一个事务读取了未提交事务执行过程中的数据。  
当一个事务的操作正在多次修改数据，而在事务还未提交的时候，另外一个并发事务来读取了数据，就会导致读取到的数据并非是最终持久化之后的数据，这个数据就是脏读的数据。
### 不可重复读
不可重复读是指对于数据库中的某个数据，一个事务执行过程中多次查询返回不同查询结果，这就是在事务执行过程中，数据被其他事务提交修改了。  
### 幻读
幻读是事务非独立执行时发生的一种现象，例如事务T1批量对一个表中某一列列值为1的数据修改为2的变更，但是在这时，事务T2对这张表插入了一条列值为1的数据，并完成提交。此时，如果事务T1查看刚刚完成操作的数据，发现还有一条列值为1的数据没有进行修改，而这条数据其实是T2刚刚提交插入的，这就是幻读。  
幻读和不可重复读都是读取了另一条已经提交的事务（这点同脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。